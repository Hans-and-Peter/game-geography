chmod 755 ./pipeline/*.rb
# TODO snapci: we do not know how to propagate variables
export artefact_version=$(cat artefact_version)

# add AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_DEFAULT_REGION as secure environment variables

# TODO aws: give proper name to instance
# create new Docker container instance to have enough free instances
# ami-e012d48f ... ECS base image for micro, see http://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_container_instance.html
export instance_id=$(aws ec2 run-instances --count 1 --image-id ami-e012d48f --instance-type t2.micro --security-group-ids sg-e63e338e \
--subnet-id subnet-43f2632b --iam-instance-profile Arn="arn:aws:iam::081374885386:instance-profile/ecsInstanceRole" \
--associate-public-ip-address \
--output text --query 'Instances[*].InstanceId')

aws ec2 wait instance-status-ok --instance-ids "$instance_id"

export serviceName=$( ./pipeline/deploy_service.rb $artefact_version )
echo $serviceName

# wait for task to become active
aws ecs wait services-stable --services "$serviceName"
export task_id=$( aws ecs list-tasks --service-name "$serviceName" --output text --query 'taskArns' )
echo $task_id
aws ecs wait tasks-running --tasks "$task_id"
# get container instance of task
export task_container_id=$( aws ecs describe-tasks --tasks "$task_id" \
--output text --query 'tasks[*].containerInstanceArn' )
export task_instance_id=$( aws ecs describe-container-instances --container-instances "$task_container_id" \
--output text --query 'containerInstances[*].ec2InstanceId' )
# get public ip of container instance
export public_host=$( aws ec2 describe-instances --instance-id $task_instance_id \
--output text --query 'Reservations[*].Instances[*].NetworkInterfaces[*].Association.PublicDnsName' )

cd systemtest
mvn clean compile failsafe:integration-test failsafe:verify -Dgame.environment.baseuri=http://$public_host -Dgame.environment.port=8080 -Dgame.serviceVersion=$artefact_version
cd ..

# TODO build: finally
aws ecs update-service --service "${serviceName}" --desired-count 0 > dev/nul
aws ecs delete-service --service "${serviceName}" > dev/nul

aws ec2 terminate-instances --instance-ids "$instance_id" > dev/nul

# TODO aws: alternative/production way
# change ELB to the new instance
# wait for old instance to have zero load
# terminate old instance
